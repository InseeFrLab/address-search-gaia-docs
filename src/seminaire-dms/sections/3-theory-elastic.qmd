## C'est quoi ElasticSearch ?

- [**ElasticSearch**]{.blue2} : logiciel pour l'indexation et la recherche de donn√©es.

- Utilisation en pratique avec [**Python**]{.green2} : packages *elasticsearch* et *elasticsearch-dsl*.


## Pourquoi ElasticSearch pour la recherche textuelle ?

| **Crit√®res**                         | **Elasticsearch** | **SQL** | **Addok\***|
|:-------------------------------------|:-----------------:|:-------:|:-------:|
| Recherche de texte avanc√©e           | ‚úÖ | ‚ùå | ‚úÖ |
| Rapidit√©                             | ‚úÖ | ‚úÖ | ‚ö†Ô∏è |
| Pr√©cision                            | ‚úÖ | ‚ùå | ‚ö†Ô∏è |
| Personnalisation des recherches      | ‚úÖ | ‚ùå | ‚ùå |
| Facilit√© d'impl√©mentation            | ‚ùå | ‚úÖ | ‚úÖ |
| Ressources                           | ‚ùå | ‚úÖ | ‚úÖ |

**\*Addok**: g√©ocodeur de la BAN.

<!-- a refaire car je ne connais pas addok, j'ai pas compris -->

<!-- | **Crit√®res**                     | **Elasticsearch (Avantages)**                                                                                             | **SQL (Inconv√©nients)**                                                                                       |
|----------------------------------|----------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| **Recherche de texte avanc√©e**   | Con√ßu pour la recherche full-text avec tol√©rance aux fautes d'orthographe (fuzzy search, correspondance partielle)         | Requ√™tes full-text limit√©es et moins adapt√©es aux variations d'orthographe                                    |
| **Performances**                 | Optimis√© pour les recherches intensives sur de gros volumes de texte                                                       | Moins performant pour des recherches complexes ou de grandes quantit√©s de donn√©es textuelles                  |
| **Personnalisation des scores**  | Permet de pond√©rer et personnaliser les scores des r√©sultats pour une meilleure pertinence                                | Les options de personnalisation des scores sont limit√©es                                                      |
| **Scalabilit√©**                  | Distribution facile sur plusieurs n≈ìuds pour g√©rer de grands ensembles de donn√©es                                         | Scalabilit√© plus complexe et generalement moins performante pour des recherches intensives                    |
| **Flexibilit√© des requ√™tes**     | Recherches avanc√©es comme les synonymes, phon√©tique, et suggestions automatiques                                          | Requ√™tes avanc√©es limit√©es, difficile √† impl√©menter en SQL                                                    |
| **Complexit√© d'impl√©mentation**  | Peut √™tre complexe √† mettre en ≈ìuvre pour des √©quipes non famili√®res avec l'outil                                         | Plus simple et souvent mieux ma√Ætris√© par les √©quipes                                                        |
| **Consommation des ressources**  | Consomme plus de m√©moire et de CPU, en particulier pour l'indexation initiale                                             | Consommation de ressources generalement inf√©rieure pour des requ√™tes simples                                  |
| **Co√ªt de stockage**             | Peut impliquer une duplication des donn√©es (co√ªt suppl√©mentaire de stockage)                                              | Pas de duplication n√©cessaire                                                                                 | -->

## Outils pour cr√©er un moteur ElasticSearch

- [**Mappings**]{.blue2} üè∑Ô∏è : sp√©cifier les traitements √† appliquer pour chaque variable.
- [**Settings**]{.blue2} üõ†Ô∏è : d√©finir les diff√©rents traitements.
- [**Requ√™tes**]{.blue2} üîç : recherche sur les variables d√©finies dans les mappings.

::: {.notes}
Et √©ventuellement, savoir coder en Python/Java...
::: 

On peut commencer √† cr√©er notre moteur ‚öôÔ∏è.

# √âtape 1 : pouvoir comparer l'adresse recherch√©e avec les donn√©es Ga√Øa.

## Filtres

- D√©finis dans les settings üõ†Ô∏è.  
- Normalisent les donn√©es.  
- Pour les donn√©es du r√©f√©rentiel et pour les adresses recherch√©es.

## Filtres impl√©ment√©s

- Lowercase  
- Asciifolding  
- Ponctuation  
- S√©paration des nombres et lettres *(ex : 14bis ‚Üí 14 bis)*  
- Suppression des espaces suppl√©mentaires  
- [**Dillatation des accronymes/prise en compte des synonymes**]{.red2}  

# √âtape 2 : d√©finir un score.

## Base de donn√©es classique

*Exemple*  

| idVoie | nom de voie             |
|---|:-----------------------------|
| A | du general leclerc           |
| B | du general charles de gaulle |
| C | du point du jour             |
| D | verdier                      |
| E | des cours                    |

## Recherche par token

[**Un token = un mot**]{.green2}  

Pour chaque token de l'adresse recherch√©e, il faut compter le nombre de match üéØ avec les tokens [**des noms de voie du r√©f√©rentiel**]{.blue2}.

Pour **"88 avenue du general charles de gaulle"**, compter le nombre de :  "88", "avenue", "du", "general"... dans tous les noms de voie.

## Score par token

[**Pour retourner la voie la plus pertinente**]{.blue2}, on construit un score pour chaque voie :
$$
\sum_{\text{‚àÄt} \in \text{T}} {nb\_occurrence}_t
$$

t = token  
T = ensemble des tokens de l'adresse recherch√©e  

## Score par token

*Exemple : score par token de "88 avenue du general charles de gaulle"*

| idVoie | nom de voie             | score |
|---|:-----------------------------|-------|
| A | **du general** leclerc           | 2     |
| B | **du general charles de gaulle** | 5     |
| C | **du** point **du** jour         | 2     |
| D | verdier                          | 0     |
| E | des cours                        | 0     |

[**Dans une grande base de donn√©es, c'est extr√™ment long.**]{.red2}

# √âtape 3 : utiliser un index invers√©. Mais qu'est ce donc ?

## Index invers√© token

*Exemple*  

<!-- | idVoie | nom de voie             |                        | token     | occurrences              |
|---|:-----------------------------|                        |-----------|--------------------------|
| A | du general leclerc           |                        | general   | {"A": 1, "B": 1}         |
| B | du general charles de gaulle |        devient         | jour      | {"C": 1}                 |
| C | du point du jour             |                        | du        | {"A": 1, "B": 1, "C": 2} |
| D | verdier                      |                        | ...       | ...                      |
| E | des cours                    | -->

<div style="display: flex; justify-content: space-between;">

<table>
  <thead>
    <tr>
      <th>idVoie</th>
      <th>nom de voie</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>du general leclerc</td>
    </tr>
    <tr>
      <td>B</td>
      <td>du general charles de gaulle</td>
    </tr>
    <tr>
      <td>C</td>
      <td>du point du jour</td>
    </tr>
    <tr>
      <td>D</td>
      <td>verdier</td>
    </tr>
    <tr>
      <td>E</td>
      <td>des cours</td>
    </tr>
  </tbody>
</table>

<!-- Ajoutez un espacement entre les deux tableaux -->
<div style="margin-left: 130px;"></div>

<table>
  <thead>
    <tr>
      <th>token</th>
      <th>occurrences</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>general</td>
      <td>{"A": 1, "B": 1}</td>
    </tr>
    <tr>
      <td>jour</td>
      <td>{"C": 1}</td>
    </tr>
    <tr>
      <td>du</td>
      <td>{"A": 1, "B": 1, "C": 2}</td>
    </tr>
    <tr>
      <td>cours</td>
      <td>{"E": 1}</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
  </tbody>
</table>
</div>

[**Comptage direct ‚ö° des occurrences**]{.green2} de chaque token de la base par idVoie.

::: {.notes}
Faire un index invers√© par token, c'est r√©cup√©rer tous les tokens des noms de voie dans le r√©f√©rentiel et on les applati dans une colonne.

Nous obtenons directement le comptage de chaque token par idVoie, pour tous les tokens pr√©sents dans les noms de voie du r√©f√©rentiel.
::: 

# √âtape 4 : prendre en compte les variations textuelles.

## Recherche par n-grams de caract√®res

[**Contourner les fautes d'orthographes**]{.blue2} : chaque token est d√©coup√© en sous-cha√Ænes de n caract√®res cons√©cutifs.  

*Exemple de d√©coupage en 3-grams de caract√®res du texte "avenue verdier" :*  
**ave, ven, enu, nue, ver, erd, rdi, die, ier**

<!-- | token    | 3-grams                 |
|----------|-------------------------|
| avenue   | ave, ven, enu, nue      |
| verdier  | ver, erd, rdi, die, ier | -->


## Index invers√© 3-grams

*Exemple*  

<!-- | 3-grams | occurrences           |
|---------|-----------------------|
| gen     | {"A": 1, "B": 1}      |
| char    | {"B": 1}              |
| our     | {"C": 1, "E": 1}      |
| ...     | ...                   | -->



<div style="display: flex; justify-content: space-between;">

<table>
  <thead>
    <tr>
      <th>idVoie</th>
      <th>nom de voie</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>du general leclerc</td>
    </tr>
    <tr>
      <td>B</td>
      <td>du general charles de gaulle</td>
    </tr>
    <tr>
      <td>C</td>
      <td>du point du jour</td>
    </tr>
    <tr>
      <td>D</td>
      <td>verdier</td>
    </tr>
    <tr>
      <td>E</td>
      <td>des cours</td>
    </tr>
  </tbody>
</table>

<!-- Ajoutez un espacement entre les deux tableaux -->
<div style="margin-left: 130px;"></div>

<table>
  <thead>
    <tr>
      <th>3-gram</th>
      <th>occurrences</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>gen</td>
      <td>{"A": 1, "B": 1}</td>
    </tr>
    <tr>
      <td>char</td>
      <td>{"B": 1}</td>
    </tr>
    <tr>
      <td>our</td>
      <td>{"C": 1, "E": 1}</td>
    </tr>
    <tr>
      <td>oin</td>
      <td>{"C": 1}</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
  </tbody>
</table>
</div>

## Score par n-grams

Pour retourner la voie la plus pertinente, on construit un score pour chaque voie :
$$
\sum_{\text{‚àÄngram} \in \text{N}} {nb\_occurrence}_{ngram}
$$

N = ensemble des n-grams de l'adresse recherch√©e

## Limites des n-grams

$$
\downarrow \text{taille n-grams}
\Rightarrow \text{taille index invers√©} \uparrow 
\Rightarrow \text{temps de recherche} \uparrow
$$

Limitation √† minimum n‚àà{3,4,5} pour notre cas.

## Fuzziness

Contourner les fautes d'orthographes d'une autre fa√ßon : [**fuzziness**]{.green2}  

Pour matcher deux tokens avec une fuzziness de niveau 1 = corriger l'un des tokens :

- Ajout d'une lettre.  
- Suppression d'une lettre.  
- Remplacement d'une lettre.  
- √âchanger deux lettres de place.  

## Score global 

Le score global va donc combiner la somme des matchs au niveau :

- token.  
- n-grams.  
- fuzziness.  

Ce score prendra en compte : 

- Les [**boosts**]{.green2}.  
- Le niveau de fuzziness choisis.  

Ceci constitue [**la requ√™te**]{.blue2} üîç.

## Boost

On peut donner plus ou moins d'importance aux diff√©rents matchs gr√¢ce aux [**boosts**]{.green2}  

Chaque occurrence est multipli√©e par un facteur qui d√©pend du niveau de match : [**boost**]{.blue2}  

*Boosts actuels :*

| match au niveau | boost |
|----------|----|
| token    | 20 |
| fuzzi 1  | 15 |
| 3-grams  | 1  |
| 4-ngrams | 1  |
| 5-grams  | 1  |

## Retour sur le score global

$$
\sum_{\text{‚àÄdn} \in \text{N}} \sum_{\text{‚àÄsc} \in \text{dn}} boost_{dn}*{nb\_occurrence}_{sc}
$$

N = ensemble des niveaux de d√©coupage de l'adresse recherch√©e *(niveau token, niveau fuzzi...)*  
dn = d√©coupage de l'adresse recherch√©e selon le niveau *(boost associ√©)*  
sc = sous-cha√Æne *(un token, un 3-grams...)*  

## Configurer le moteur ‚öôÔ∏è

Une fois qu'on a la th√©orie, il faut l'appliquer en pratique.  

Le package elasticsearch permet d'indexer les donn√©es en fournissant :  

- Un dataframe üìã des donn√©es du r√©f√©rentiel Ga√Øa.  
- Des [**settings**]{.blue2} üõ†Ô∏è o√π on d√©finit nos diff√©rents **analyzers**, englobant les filtres et le tokenizer.  
- Des [**mappings**]{.green2} üè∑Ô∏è o√π pour chaque **variable**, on fournit un analyzer.  

## Faire des recherches

Une fois le moteur configur√©, on peut faire des requ√™tes üîç.

*Requ√™te pour retrouver la voie :*

- Match üéØ token sur nom de voie avec fuzzi 1 ‚Üí boost 20.  
- Match üéØ token sur type de voie ou nom de voie ‚Üí boost 15.  
- Match üéØ 3 √† 5-grams sur nom de voie ‚Üí boost 1.  

$$
\text{√Ä chaque fois qu'une sous-cha√Æne valide l'une de ces conditions, le score va} \uparrow \text{en fonction du boost associ√©}.  
$$