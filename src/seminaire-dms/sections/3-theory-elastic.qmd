## Adresses Ã  retrouver dans GaÃ¯a

###### *Exemple d'adresses Ã  retrouver :*

| **Adresse Ã  retrouver** | **COG** | **Code Postal** | **LibellÃ© commune** |
|-------------------------|---------|-----------------|---------------------|
| 131, rue du fbg Bannier |         | 45000           | OrlÃ©ans             |
| 0033 ave J. JaurÃ¨s      | 92040   |                 |                     |

###### *Adresses dans GaÃ¯a :*

| **Adresse**                 | **COG** |
|-----------------------------|---------|
| 131 rue du faubourg bannier | 45234   |
| 33 avenue jean jaures       | 92040   |

::: {.notes}
C'est pourquoi il faut un moteur de recherche âš™ï¸.
:::

## Un moteur de recherche âš™ï¸

- **Google** : recherche par mot clÃ© sur internet.  
- Moteur de recherche de l'intranet de l'Insee.    
- Pour la recherche d'adresse :  
  - **Google Maps**.
  - **Addok** : moteur de recherche de la BAN.  

![](img/frise_moteur.png){width=75% fig-align="center"}

::: {.notes}
- Quand on pense Ã  moteur de recherche, on pense tout de suite Ã  Google.  

- Un moteur de recherche est un outil qui permet de retrouver des informations en effectuant des requÃªtes dans une base de donnÃ©es. On peut rechercher avec des mots-clÃ©s ou des textes similaires Ã  ceux prÃ©sents dans la base, grÃ¢ce Ã  des techniques de recherche approximative.  
- Un moteur ne sert pas qu'Ã  chercher sur internet, c'est tout simplement de la recherche dans une base de donnÃ©es. Mais internet a permis des avancÃ©es majeures sur les moteurs, car la recherche sur le web devenait un sujet de plus en plus important. Avec le dÃ©multiplication de l'information, difficile de chercher dans une grande bdd et trouver le rÃ©sultat le plus pertinent.  

- Pour avoir le maximum de rÃ©sultats pertients, il faut non seulement avoir un moteur performant, il faut aussi avoir les bonnes donnÃ©es. C'est en recrutant un Ã©tudiant du MIT qui a dÃ©veloppÃ© une mÃ©thode rÃ©volutionnaire pour recenser automatiquement les sites sur le web (auparavant fait manuellement), que google va se dÃ©marquer des autres moteurs.  

- 1er moteur de recherche Archie 1990. Yahoo 1994, Google 1998, google maps 2004.  

- Google maps : api payant, pas la main sur les donnÃ©es.  
- Google Maps utilise des technologies avancÃ©es mais on peut reproduire la logique avec ElasticSearch.  
- Addock : DINUM
::: 

## ElasticSearch 

- CrÃ©Ã© en **2010** par Shay Bannon.  
- Moteur âš™ï¸ utilisable en [**n'importe quel langage de programmation**]{.green2} (requÃªtes HTTP).  
- Faire des recherches rapides sur tout type de donnÃ©es.  

ElasticSearch au sein de l'Insee :  

![](img/frise_es.png){width=75% fig-align="center"}

::: {.notes}
- Pour trier et chercher les recettes de cuisine de sa femme psq il trouvait pas de moteur de recherche adaptÃ©.  

- 1er moteur Elasticsearch de l'insee : Code statistique Non Signifiant, identifier les individus Ã  partir de ses donnÃ©es dâ€™Ã©tat civil.  

- RÃ©sil : prolongement du moteur CSNS, amÃ©liorer la qualitÃ© du moteur CSNS, en utilisant les informations identifiantes supplÃ©mentaires disponibles dans RÃ©sil, notamment lâ€™adresse de rÃ©sidence et les cohabitants.  
:::

## C'est quoi concrÃ¨tement ElasticSearch ?

- [**ElasticSearch**]{.blue2} : logiciel pour l'indexation et la recherche de donnÃ©es.

- Utilisation en pratique avec [**Python**]{.green2} : packages *elasticsearch* et *elasticsearch-dsl*.


## Pourquoi ElasticSearch pour la recherche textuelle ?

| **CritÃ¨res**                         | **ElasticSearch** | **SQL** | **Addok**|
|:-------------------------------------|:-----------------:|:-------:|:-------:|
| Recherche de texte avancÃ©e           | âœ… | âŒ | âœ… |
| Personnalisation des recherches      | âœ… | âŒ | âŒ |
| RapiditÃ©                             | âœ… | âœ… | âœ… |
| PrÃ©cision                            | âœ… | âŒ | âš ï¸ |
| FacilitÃ© d'implÃ©mentation            | âŒ | âœ… | âœ… |
| Maintenance                          | âš ï¸ | âœ… | âŒ |

::: {.notes}
Addok (DINUM) : code python pour indexer des donnÃ©es d'adresses avec point gps et recherche les adresses avec des requÃªtes fixÃ©es.  
::: 

<!-- a refaire car je ne connais pas addok, j'ai pas compris -->

<!-- | **CritÃ¨res**                     | **Elasticsearch (Avantages)**                                                                                             | **SQL (InconvÃ©nients)**                                                                                       |
|----------------------------------|----------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| **Recherche de texte avancÃ©e**   | ConÃ§u pour la recherche full-text avec tolÃ©rance aux fautes d'orthographe (fuzzy search, correspondance partielle)         | RequÃªtes full-text limitÃ©es et moins adaptÃ©es aux variations d'orthographe                                    |
| **Performances**                 | OptimisÃ© pour les recherches intensives sur de gros volumes de texte                                                       | Moins performant pour des recherches complexes ou de grandes quantitÃ©s de donnÃ©es textuelles                  |
| **Personnalisation des scores**  | Permet de pondÃ©rer et personnaliser les scores des rÃ©sultats pour une meilleure pertinence                                | Les options de personnalisation des scores sont limitÃ©es                                                      |
| **ScalabilitÃ©**                  | Distribution facile sur plusieurs nÅ“uds pour gÃ©rer de grands ensembles de donnÃ©es                                         | ScalabilitÃ© plus complexe et generalement moins performante pour des recherches intensives                    |
| **FlexibilitÃ© des requÃªtes**     | Recherches avancÃ©es comme les synonymes, phonÃ©tique, et suggestions automatiques                                          | RequÃªtes avancÃ©es limitÃ©es, difficile Ã  implÃ©menter en SQL                                                    |
| **ComplexitÃ© d'implÃ©mentation**  | Peut Ãªtre complexe Ã  mettre en Å“uvre pour des Ã©quipes non familiÃ¨res avec l'outil                                         | Plus simple et souvent mieux maÃ®trisÃ© par les Ã©quipes                                                        |
| **Consommation des ressources**  | Consomme plus de mÃ©moire et de CPU, en particulier pour l'indexation initiale                                             | Consommation de ressources generalement infÃ©rieure pour des requÃªtes simples                                  |
| **CoÃ»t de stockage**             | Peut impliquer une duplication des donnÃ©es (coÃ»t supplÃ©mentaire de stockage)                                              | Pas de duplication nÃ©cessaire                                                                                 | -->

<!-- ## Outils pour moteur ElasticSearch

- [**Mappings**]{.blue2} ğŸ·ï¸ : spÃ©cifier les traitements Ã  appliquer pour chaque variable de nos donnÃ©es.  
  - *Variable_a â†’ Analyzer_for_numbers*  
  - *Variable_b â†’ Analyzer_for_address_text*  
  - *Variable_c â†’ Analyzer_for_address_text*  
- [**Settings**]{.blue2} ğŸ› ï¸ : dÃ©finir les diffÃ©rents traitements.  
  - *Analyzer_for_numbers â†’ Filtre_Î±, Filtre_Î² + Tokenizer_1*  
  - *Analyzer_for_address_text â†’ Filtre_Î³, Filtre_Î´, Filtre_Îµ + Tokenizer_2*  
- [**RequÃªtes**]{.blue2} ğŸ” : recherche sur les variables dÃ©finies dans les mappings.  

::: {.notes}
Et Ã©ventuellement, savoir coder en Python/Java...
::: 

On peut commencer Ã  crÃ©er notre moteur âš™ï¸. -->

# Ã‰tape 1 : pouvoir comparer l'adresse recherchÃ©e avec les donnÃ©es GaÃ¯a.

## Filtres

<!-- - DÃ©finis dans les *settings* ğŸ› ï¸.   -->
- Normaliser le texte pour la comparaison.  
- Pour les [**donnÃ©es du rÃ©fÃ©rentiel**]{.green2} ET pour les [**adresses recherchÃ©es**]{.blue2}.

## Filtres implÃ©mentÃ©s

- Lowercase  
- Asciifolding  
- Ponctuation  
- SÃ©paration des nombres et lettres *(ex : 1er â†’ 1 er)*  
- Suppression des "0" devant les nombres *(ex : 0033 â†’ 33)*  
- [**Prise en compte des synonymes**]{.red2}  *(ex : ave = avenue, st = saint)*  

# Ã‰tape 2 : dÃ©finir un score pour Ã©valuer la pertinence.

## Base de donnÃ©es classique

*Exemple*  

| idVoie | nom de voie             |
|---|:-----------------------------|
| A | du general leclerc           |
| B | du general charles de gaulle |
| C | du point du jour             |
| D | verdier                      |
| E | des cours                    |

::: {.notes}
Nous allons faire un focus sur uniquement le "nom de voie" pour simplifier la comprÃ©hension de la thÃ©orie du moteur.  
:::

## Recherche par mot

[**Pour chaque nom de voie du rÃ©fÃ©rentiel**]{.blue2}, compter le nombre de mots qui sont retrouvÃ©s dans l'adresse recherchÃ©e : les **matchs** ğŸ¯.  

*Exemple : score avec tokenizer "mot" de "45 avenue du general charles de gaulle"*

| idVoie | nom de voie             | score |
|---|:-----------------------------|-------|
| A | **du general** leclerc           | 2     |
| B | **du general charles de gaulle** | 5     |
| C | **du** point **du** jour         | 2     |
| D | verdier                          | 0     |
| E | des cours                        | 0     |

::: {.notes}
- Un match c'est chercher si une sous chaine du nom de voie, ici un mot, est incluse dans l'adresse recherchÃ©e.  
- Recherche par groupes de caractÃ¨res Ã©galement possible, abordÃ©e dans la suite.   
:::

## Score avec tokenizer "mot"

[**Tokenizer**]{.green2} = faÃ§on de dÃ©couper le texte recherchÃ© et ciblÃ©.  

<br>

[**Pour retourner la voie la plus pertinente**]{.blue2}, on construit un score pour chaque voie :
$$
score_{voie} = \sum_{\text{âˆ€m} \in \text{M}} {nb\_occurrence}_m
$$

m = mot.  
M = ensemble des mots de l'adresse recherchÃ©e.  

[**Dans une grande base de donnÃ©es, c'est extrÃªmement long.**]{.red2}

::: {.notes}
Pour palier Ã  ces temps de traitement qui explosent, on peut utiliser un nouvel outil qui permet de rÃ©organiser nos bases de donnÃ©es : l'index inversÃ©.  
:::

# Ã‰tape 3 : utiliser un index inversÃ©. Mais qu'est ce donc ?

## Index inversÃ© mot

*Exemple*  

<!-- | idVoie | nom de voie             |                        | mot     | occurrences              |
|---|:-----------------------------|                        |-----------|--------------------------|
| A | du general leclerc           |                        | general   | {"A": 1, "B": 1}         |
| B | du general charles de gaulle |        devient         | jour      | {"C": 1}                 |
| C | du point du jour             |                        | du        | {"A": 1, "B": 1, "C": 2} |
| D | verdier                      |                        | ...       | ...                      |
| E | des cours                    | -->

<div style="display: flex; justify-content: space-between;">

<table>
  <thead>
    <tr>
      <th>idVoie</th>
      <th>nom de voie</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>du general leclerc</td>
    </tr>
    <tr>
      <td>B</td>
      <td>du general charles de gaulle</td>
    </tr>
    <tr>
      <td>C</td>
      <td>du point du jour</td>
    </tr>
    <tr>
      <td>D</td>
      <td>verdier</td>
    </tr>
    <tr>
      <td>E</td>
      <td>des cours</td>
    </tr>
  </tbody>
</table>

<!-- Ajoutez un espacement entre les deux tableaux -->
<div style="margin-left: 130px;"></div>

<table>
  <thead>
    <tr>
      <th>mot</th>
      <th>occurrences</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>general</td>
      <td>{"A": 1, "B": 1}</td>
    </tr>
    <tr>
      <td>jour</td>
      <td>{"C": 1}</td>
    </tr>
    <tr>
      <td>du</td>
      <td>{"A": 1, "B": 1, "C": 2}</td>
    </tr>
    <tr>
      <td>cours</td>
      <td>{"E": 1}</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
  </tbody>
</table>
</div>

[**Comptage direct âš¡ des occurrences**]{.green2} de chaque mot de la base par idVoie.

::: {.notes}
- Faire un index inversÃ© par mot, c'est rÃ©cupÃ©rer tous les mots des noms de voie dans le rÃ©fÃ©rentiel et on les aplati dans une colonne.  
- Il y a autant de lignes qu'il y a de mots diffÃ©rents dans les noms de voie du rÃ©fÃ©rentiel. Les mots les plus frÃ©quents seront ceux qui ont le plus d'occurences.  
- Nous obtenons directement le comptage de chaque mot par idVoie.  
- L'index inversÃ© est fait en amont des recherches.  
::: 

# Ã‰tape 4 : prendre en compte les variations textuelles.

## Fuzziness

[**Contourner les petites fautes d'orthographes**]{.blue2} : [**fuzziness**]{.green2}.  

Pour matcher ğŸ¯ deux mots avec une fuzziness de niveau 1 = corriger l'un des mots :  

- Ajout d'une lettre. *Ex: "verdiier"*  
- Suppression d'une lettre. *Ex: "verdie"*  
- Remplacement d'une lettre. *Ex: "verfier"*  
- Ã‰changer deux lettres de place. *Ex: "evrdier"*  

Il est possible de comparer deux textes, deux n-grams ou n'importe quel autre groupe de caractÃ¨res.  

::: {.notes}
La fuzziness n'est pas un tokenizer, une facon de decouper, c'est plutot une option qu'on rajoute pour matcher des sous chaine, peu importe le decoupage.
:::

## Une autre faÃ§on de dÃ©couper : les n-grams

[**Prendre en compte les correspondances partielles**]{.blue2} : chaque mot est dÃ©coupÃ© en sous-chaÃ®nes de n caractÃ¨res consÃ©cutifs.  

<br>

*Exemple de dÃ©coupage en 3-grams de caractÃ¨res du texte "avenue verdier" :*  
**ave, ven, enu, nue, ver, erd, rdi, die, ier**  

<br>

Si un mot est infÃ©rieur Ã  la taille n, il n'aura pas de dÃ©coupage en n-grams â†’ pas prÃ©sent dans l'index inversÃ© n-gram.  


## Index inversÃ© 3-grams

*Exemple*  

<!-- | 3-grams | occurrences           |
|---------|-----------------------|
| gen     | {"A": 1, "B": 1}      |
| cha     | {"B": 1}              |
| our     | {"C": 1, "E": 1}      |
| ...     | ...                   | -->



<div style="display: flex; justify-content: space-between;">

<table>
  <thead>
    <tr>
      <th>idVoie</th>
      <th>nom de voie</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>du general leclerc</td>
    </tr>
    <tr>
      <td>B</td>
      <td>du general charles de gaulle</td>
    </tr>
    <tr>
      <td>C</td>
      <td>du point du jour</td>
    </tr>
    <tr>
      <td>D</td>
      <td>verdier</td>
    </tr>
    <tr>
      <td>E</td>
      <td>des cours</td>
    </tr>
  </tbody>
</table>

<!-- Ajoutez un espacement entre les deux tableaux -->
<div style="margin-left: 40px;"></div>

<table>
  <thead>
    <tr>
      <th>3-gram</th>
      <th>occurrences</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>gen</td>
      <td>{"A": 1, "B": 1}</td>
    </tr>
    <tr>
      <td>cha</td>
      <td>{"B": 1}</td>
    </tr>
    <tr>
      <td>our</td>
      <td>{"C": 1, "E": 1}</td>
    </tr>
    <tr>
      <td>oin</td>
      <td>{"C": 1}</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
  </tbody>
</table>
</div>

::: {.notes}
- Il y a autant de lignes qu'il ya de trigrams diffÃ©rents dans les noms de voie du rÃ©fÃ©rentiel.  
- Si un mot est infÃ©rieur Ã  la taille n=3, il ne sera pas pris en compte. Par exemple : du gÃ©nÃ©ral de gaules, "du" et "de" nâ€™apparaÃ®tront pas dans l'index et donc ne seront pas pris en compte dans les matchs trigrams.  
:::

## Score avec tokenizer "n-grams"

Score pour chaque voie :
$$
score_{voie} = \sum_{\text{âˆ€ngram} \in \text{N}} {nb\_occurrence}_{ngram}
$$

N = ensemble des n-grams de l'adresse recherchÃ©e.  

## Limites des n-grams

$$
\downarrow \text{taille n-grams}
\Rightarrow \text{taille index inversÃ©} \uparrow 
\Rightarrow \text{temps de recherche} \uparrow
$$

- Limitation Ã  nâˆˆ{3,4,5} pour notre cas.  
- Tests effectuÃ©s pour choisir ces valeurs, en fonction de [**la prÃ©cision et la rapiditÃ©**]{.green2} des requÃªtes.  

::: {.notes}
Donc avec tous ces Ã©lÃ©ments, on peut commencer Ã  construire un score de plus en plus efficient pour trouver la voie la plus pertiente.
:::

## Score global 

Le score global va donc combiner la somme des matchs ğŸ¯ au niveau :

- mot avec fuzziness.  
- n-grams.  
- mais Ã©galement texte entier sans dÃ©coupage !  

<br>

Il est possible de donner plus ou moins d'importance Ã  ces diffÃ©rents niveaux de matchs ğŸ¯.  

::: {.notes}
- On va chercher le nom de voie tel quel, sans dÃ©coupage, au sein de l'adresse recherchÃ©e.  

- C'est pourquoi on va introduire la notion de boost.  
:::

<!-- ## Configurer le moteur âš™ï¸

Une fois qu'on a la thÃ©orie, il faut l'appliquer en pratique.  

Le package elasticsearch permet d'indexer les donnÃ©es en fournissant :  

- Un dataframe ğŸ“‹ des donnÃ©es du rÃ©fÃ©rentiel GaÃ¯a.  
- Des [**settings**]{.blue2} ğŸ› ï¸ oÃ¹ on dÃ©finit nos diffÃ©rents **analyzers**, englobant les filtres et le motizer.  
- Des [**mappings**]{.green2} ğŸ·ï¸ oÃ¹ pour chaque **variable**, on fournit un analyzer.   -->

## Boost ğŸš€

- Chaque occurrence est multipliÃ©e par un facteur, appelÃ© [**boost**]{.blue2} ğŸš€, qui dÃ©pend du niveau de match ğŸ¯.  
- Personnalisation des **boosts** ğŸš€ pour Ãªtre adaptÃ© aux donnÃ©es recherchÃ©es.  

::: {.notes}
Avec tous ces outils la, on peut faire une recherche !
:::

## Faire des recherches ğŸ”

*RequÃªte ğŸ” pour retrouver la voie :* 

Ã€ chaque match ğŸ¯, le score va â‡¡ en fonction du boost ğŸš€ associÃ©.

| Variable | Tokenizer | Fuzzi 1 | Boost ğŸš€ |
|----------|-----------|---------|-----------|
| Nom de voie | Sans dÃ©coupage | âœ… | 200 |
| Nom de voie | Mot | âœ… | 15 |
| Type de voie | Mot | âœ… | 5 |
| Nom de voie | 3 Ã  5-grams | âŒ | 1 |

*Ex boost 200 : "3 rue du genral de gaulle" âŠƒ "du gen[**e**]{.red2}ral de gaulle"*

::: {.notes}
- Requete gaia pour retrouver la voie.  
- Ici, on introduit le type de voie qui n'a pas Ã©tÃ© vu prÃ©cÃ©dement, pour ne pas compliquer la comprÃ©hension de la thÃ©orie du moteur, mais la logique reste la meme que pour le nom de voie.  
- Attention,  pas de fuzzi sur les ngrams car on juge que les sous chaines sont dÃ©jÃ  assez petites, c'est contre productif pour la rapiditÃ© et la prÃ©cision des recherches d'ajouter de la fuzzi.  
- Il faut noter qu'on match Ã  chaque sous-chaine, par exemple Ã  chaque 3-grams de verdier dans 88 avenue verdier.  
- Les ngrams c'est notre dernier recours, on va retourner comme voie plus pertinente les match sur nom de voie complet et sur token mais ngrams c'est notre roue de secours.  
:::

## Retour sur le score global

$$
score_{voie} = \sum_{\text{âˆ€n} \in \text{N}} \sum_{\text{âˆ€t} \in \text{n}} boost_{n}*{nb\_occurrence}_{t}
$$

N = ensemble des niveaux *(niveau chaÃ®ne complÃ¨te fuzzi, niveau mot fuzzi...)*.  
n = niveau.  
t = token, sous-chaÃ®ne *(un mot, un 3-grams...)*.  

::: {.notes}
- Formule mathÃ©matique du score pour retrouver la voie la plus pertiente dans GaÃ¯a.  

- Maintenant, on est capable de retrouver la voie la plus pertinente, mais qu'est ce qu'il en est de l'adresse ? Regardons l'algorithme d'identification d'adresse de GaÃ¯a.  
:::