## Adresses √† retrouver dans Ga√Øa

###### *Exemple d'adresses √† retrouver :*

| **Adresse √† retrouver** | **COG** | **Code Postal** | **Libell√© commune** |
|-------------------------|---------|-----------------|---------------------|
| 131, rue du fbg Bannier |         | 45000           | Orl√©ans             |
| 0033 ave J. Jaur√®s      | 92040   |                 |                     |

###### *Adresses dans Ga√Øa :*

| **Adresse**                 | **COG** |
|-----------------------------|---------|
| 131 rue du faubourg bannier | 45234   |
| 33 avenue jean jaures       | 92040   |

::: {.notes}
C'est pourquoi il faut un moteur de recherche ‚öôÔ∏è.
:::

## Un moteur de recherche ‚öôÔ∏è

- **Google** : recherche par mot cl√© sur internet.  
- Moteur de recherche de l'intranet de l'Insee.    
- Pour la recherche d'adresse :  
  - **Google Maps**.
  - **Addok** : moteur de recherche de la BAN.  

![](img/frise_moteur.png){width=75% fig-align="center"}

::: {.notes}
- Quand on pense √† moteur de recherche, on pense tout de suite √† Google.  

- Un moteur de recherche est un outil qui permet de retrouver des informations en effectuant des requ√™tes dans une base de donn√©es. On peut rechercher avec des mots-cl√©s ou des textes similaires √† ceux pr√©sents dans la base, gr√¢ce √† des techniques de recherche approximative.  

- Il y a des moteurs de recherche partout, par exemple intranet de l'insee, windows pour chercher des applications, l'explorateur de fichiers sur votre ordinateur en local...   

- Un moteur ne sert pas qu'√† chercher sur internet, c'est tout simplement de la recherche dans une base de donn√©es. Mais internet a permis des avanc√©es majeures sur les moteurs, car la recherche sur le web devenait un sujet de plus en plus important. Avec le d√©multiplication de l'information, difficile de chercher dans une grande bdd et trouver le r√©sultat le plus pertinent.  

- Pour avoir le maximum de r√©sultats pertients, il faut non seulement avoir un moteur performant, il faut aussi avoir les bonnes donn√©es. C'est en recrutant un √©tudiant du MIT qui a d√©velopp√© une m√©thode r√©volutionnaire pour recenser automatiquement les sites sur le web (auparavant fait manuellement), que google va se d√©marquer des autres moteurs.  

- 1er moteur de recherche Archie 1990. Yahoo 1994, Google 1998, google maps 2004.  

- Google maps : api payant, pas la main sur les donn√©es.  
- Google Maps utilise des technologies avanc√©es mais on peut reproduire la logique avec ElasticSearch.  
- Addok : DINUM.  
- On va regarder les avantages et les inconvients de d'elastic et d'addok dans la suite.  
::: 

## ElasticSearch 

- Cr√©√© en **2010** par Shay Bannon.  
- Faire des recherches rapides sur tout type de donn√©es.  
- Moteur ‚öôÔ∏è utilisable en [**n'importe quel langage de programmation**]{.green2} (requ√™tes HTTP).  

ElasticSearch au sein de l'Insee :  

![](img/frise_es.png){width=75% fig-align="center"}

::: {.notes}
- Pour trier et chercher les recettes de cuisine de sa femme psq il trouvait pas de moteur de recherche adapt√©.  

- 1er moteur Elasticsearch de l'insee : Code statistique Non Signifiant, identifier les individus √† partir de ses donn√©es d‚Äô√©tat civil.  

- R√©sil : prolongement du moteur CSNS, am√©liorer la qualit√© du moteur CSNS, en utilisant les informations identifiantes suppl√©mentaires disponibles dans R√©sil, notamment l‚Äôadresse de r√©sidence et les cohabitants.  
:::

## C'est quoi concr√®tement ElasticSearch ?

- [**ElasticSearch**]{.blue2} : logiciel pour l'indexation et la recherche de donn√©es.

- Utilisation en pratique avec [**Python**]{.green2} : packages *elasticsearch* et *elasticsearch-dsl*.


## Pourquoi ElasticSearch pour la recherche textuelle ?

| **Crit√®res**                         | **ElasticSearch** | **SQL** | **Addok**|
|:-------------------------------------|:-----------------:|:-------:|:-------:|
| Recherche de texte avanc√©e           | ‚úÖ | ‚ùå | ‚úÖ |
| Personnalisation des recherches      | ‚úÖ | ‚ùå | ‚ö†Ô∏è |
| Rapidit√©                             | ‚úÖ | ‚úÖ | ‚úÖ |
| Pr√©cision                            | ‚úÖ | ‚ùå | ‚ö†Ô∏è |
| Facilit√© d'impl√©mentation            | ‚ùå | ‚úÖ | ‚úÖ |
| Maintenance                          | ‚ö†Ô∏è | ‚úÖ | ‚ùå |

::: {.notes}
- Addok (DINUM) : code python pour indexer des donn√©es d'adresses avec point gps et recherche les adresses avec des requ√™tes fix√©es.  
- Addok est un moteur de recherche open source con√ßu pour effectuer des t√¢ches de g√©ocodage. Il n'utilise pas Elasticsearch.  
::: 

<!-- a refaire car je ne connais pas addok, j'ai pas compris -->

<!-- | **Crit√®res**                     | **Elasticsearch (Avantages)**                                                                                             | **SQL (Inconv√©nients)**                                                                                       |
|----------------------------------|----------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| **Recherche de texte avanc√©e**   | Con√ßu pour la recherche full-text avec tol√©rance aux fautes d'orthographe (fuzzy search, correspondance partielle)         | Requ√™tes full-text limit√©es et moins adapt√©es aux variations d'orthographe                                    |
| **Performances**                 | Optimis√© pour les recherches intensives sur de gros volumes de texte                                                       | Moins performant pour des recherches complexes ou de grandes quantit√©s de donn√©es textuelles                  |
| **Personnalisation des scores**  | Permet de pond√©rer et personnaliser les scores des r√©sultats pour une meilleure pertinence                                | Les options de personnalisation des scores sont limit√©es                                                      |
| **Scalabilit√©**                  | Distribution facile sur plusieurs n≈ìuds pour g√©rer de grands ensembles de donn√©es                                         | Scalabilit√© plus complexe et generalement moins performante pour des recherches intensives                    |
| **Flexibilit√© des requ√™tes**     | Recherches avanc√©es comme les synonymes, phon√©tique, et suggestions automatiques                                          | Requ√™tes avanc√©es limit√©es, difficile √† impl√©menter en SQL                                                    |
| **Complexit√© d'impl√©mentation**  | Peut √™tre complexe √† mettre en ≈ìuvre pour des √©quipes non famili√®res avec l'outil                                         | Plus simple et souvent mieux ma√Ætris√© par les √©quipes                                                        |
| **Consommation des ressources**  | Consomme plus de m√©moire et de CPU, en particulier pour l'indexation initiale                                             | Consommation de ressources generalement inf√©rieure pour des requ√™tes simples                                  |
| **Co√ªt de stockage**             | Peut impliquer une duplication des donn√©es (co√ªt suppl√©mentaire de stockage)                                              | Pas de duplication n√©cessaire                                                                                 | -->

<!-- ## Outils pour moteur ElasticSearch

- [**Mappings**]{.blue2} üè∑Ô∏è : sp√©cifier les traitements √† appliquer pour chaque variable de nos donn√©es.  
  - *Variable_a ‚Üí Analyzer_for_numbers*  
  - *Variable_b ‚Üí Analyzer_for_address_text*  
  - *Variable_c ‚Üí Analyzer_for_address_text*  
- [**Settings**]{.blue2} üõ†Ô∏è : d√©finir les diff√©rents traitements.  
  - *Analyzer_for_numbers ‚Üí Filtre_Œ±, Filtre_Œ≤ + Tokenizer_1*  
  - *Analyzer_for_address_text ‚Üí Filtre_Œ≥, Filtre_Œ¥, Filtre_Œµ + Tokenizer_2*  
- [**Requ√™tes**]{.blue2} üîç : recherche sur les variables d√©finies dans les mappings.  

::: {.notes}
Et √©ventuellement, savoir coder en Python/Java...
::: 

On peut commencer √† cr√©er notre moteur ‚öôÔ∏è. -->

# √âtape 1 : pouvoir comparer l'adresse recherch√©e avec les donn√©es Ga√Øa.

## Filtres

<!-- - D√©finis dans les *settings* üõ†Ô∏è.   -->
- Normaliser le texte pour la comparaison.  
- Pour les [**donn√©es du r√©f√©rentiel**]{.green2} ET pour les [**adresses recherch√©es**]{.blue2}.

## Filtres impl√©ment√©s

- Lowercase  
- Asciifolding  
- Ponctuation  
- S√©paration des nombres et lettres *(ex : 1er ‚Üí 1 er)*  
- Suppression des "0" devant les nombres *(ex : 0033 ‚Üí 33)*  
- [**Prise en compte des synonymes**]{.red2}  *(ex : ave = avenue, st = saint)*  

# √âtape 2 : d√©finir un score pour √©valuer la pertinence.

## Base de donn√©es classique

*Exemple*  

| idVoie | nom de voie             |
|---|:-----------------------------|
| A | du general leclerc           |
| B | du general charles de gaulle |
| C | du point du jour             |
| D | verdier                      |
| E | des cours                    |

::: {.notes}
Nous allons faire un focus sur uniquement le "nom de voie" pour simplifier la compr√©hension de la th√©orie du moteur.  
:::

## Recherche par mot

[**Pour chaque nom de voie du r√©f√©rentiel**]{.blue2}, compter le nombre de mots qui sont retrouv√©s dans l'adresse recherch√©e : les **matchs** üéØ.  

*Exemple : score avec tokenizer "mot" de "45 avenue du general charles de gaulle"*

| idVoie | nom de voie             | score |
|---|:-----------------------------|-------|
| A | **du general** leclerc           | 2     |
| B | **du general charles de gaulle** | 5     |
| C | **du** point **du** jour         | 2     |
| D | verdier                          | 0     |
| E | des cours                        | 0     |

::: {.notes}
- Un match c'est chercher si une sous chaine du nom de voie, ici un mot, est incluse dans l'adresse recherch√©e.  
- Recherche par groupes de caract√®res √©galement possible, abord√©e dans la suite.   
:::

## Score avec tokenizer "mot"

[**Tokenizer**]{.green2} = fa√ßon de d√©couper le texte recherch√© et cibl√©.  

<br>

[**Pour retourner la voie la plus pertinente**]{.blue2}, on construit un score pour chaque voie :
$$
score_{voie} = \sum_{\text{‚àÄm} \in \text{M}} {nb\_occurrence}_m
$$

m = mot.  
M = ensemble des mots de l'adresse recherch√©e.  

[**Dans une grande base de donn√©es, c'est extr√™mement long.**]{.red2}

::: {.notes}
Pour palier √† ces temps de traitement qui explosent, on peut utiliser un nouvel outil qui permet de r√©organiser nos bases de donn√©es : l'index invers√©.  
:::

# √âtape 3 : utiliser un index invers√©. Mais qu'est ce donc ?

## Index invers√© mot

*Exemple*  

<!-- | idVoie | nom de voie             |                        | mot     | occurrences              |
|---|:-----------------------------|                        |-----------|--------------------------|
| A | du general leclerc           |                        | general   | {"A": 1, "B": 1}         |
| B | du general charles de gaulle |        devient         | jour      | {"C": 1}                 |
| C | du point du jour             |                        | du        | {"A": 1, "B": 1, "C": 2} |
| D | verdier                      |                        | ...       | ...                      |
| E | des cours                    | -->

<div style="display: flex; justify-content: space-between;">

<table>
  <thead>
    <tr>
      <th>idVoie</th>
      <th>nom de voie</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>du general leclerc</td>
    </tr>
    <tr>
      <td>B</td>
      <td>du general charles de gaulle</td>
    </tr>
    <tr>
      <td>C</td>
      <td>du point du jour</td>
    </tr>
    <tr>
      <td>D</td>
      <td>verdier</td>
    </tr>
    <tr>
      <td>E</td>
      <td>des cours</td>
    </tr>
  </tbody>
</table>

<!-- Ajoutez un espacement entre les deux tableaux -->
<div style="margin-left: 130px;"></div>

<table>
  <thead>
    <tr>
      <th>mot</th>
      <th>occurrences</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>general</td>
      <td>{"A": 1, "B": 1}</td>
    </tr>
    <tr>
      <td>jour</td>
      <td>{"C": 1}</td>
    </tr>
    <tr>
      <td>du</td>
      <td>{"A": 1, "B": 1, "C": 2}</td>
    </tr>
    <tr>
      <td>cours</td>
      <td>{"E": 1}</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
  </tbody>
</table>
</div>

[**Comptage direct ‚ö° des occurrences**]{.green2} de chaque mot de la base par idVoie.

::: {.notes}
- Faire un index invers√© par mot, c'est r√©cup√©rer tous les mots des noms de voie dans le r√©f√©rentiel et on les aplati dans une colonne.  
- Il y a autant de lignes qu'il y a de mots diff√©rents dans les noms de voie du r√©f√©rentiel. Les mots les plus fr√©quents seront ceux qui ont le plus d'occurences.  
- Nous obtenons directement le comptage de chaque mot par idVoie.  
- L'index invers√© est fait en amont des recherches.  
::: 

# √âtape 4 : prendre en compte les variations textuelles.

## Fuzziness

[**Contourner les petites fautes d'orthographes**]{.blue2} : [**fuzziness**]{.green2}.  

Pour matcher üéØ deux mots avec une fuzziness de niveau 1 = corriger l'un des mots :  

- Ajout d'une lettre. *Ex: "verdiier"*  
- Suppression d'une lettre. *Ex: "verdie"*  
- Remplacement d'une lettre. *Ex: "verfier"*  
- √âchanger deux lettres de place. *Ex: "evrdier"*  

Il est possible de comparer deux textes, deux n-grams ou n'importe quel autre groupe de caract√®res.  

::: {.notes}
La fuzziness n'est pas un tokenizer, une facon de decouper, c'est plutot une option qu'on rajoute pour matcher des sous chaine, peu importe le decoupage.
:::

## Une autre fa√ßon de d√©couper : les n-grams

[**Prendre en compte les correspondances partielles**]{.blue2} : chaque mot est d√©coup√© en sous-cha√Ænes de n caract√®res cons√©cutifs.  

<br>

*Exemple de d√©coupage en 3-grams de caract√®res du texte "avenue verdier" :*  
**ave, ven, enu, nue, ver, erd, rdi, die, ier**  

<br>

Si un mot est inf√©rieur √† la taille n, il n'aura pas de d√©coupage en n-grams ‚Üí pas pr√©sent dans l'index invers√© n-gram.  


## Index invers√© 3-grams

*Exemple*  

<!-- | 3-grams | occurrences           |
|---------|-----------------------|
| gen     | {"A": 1, "B": 1}      |
| cha     | {"B": 1}              |
| our     | {"C": 1, "E": 1}      |
| ...     | ...                   | -->



<div style="display: flex; justify-content: space-between;">

<table>
  <thead>
    <tr>
      <th>idVoie</th>
      <th>nom de voie</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>du general leclerc</td>
    </tr>
    <tr>
      <td>B</td>
      <td>du general charles de gaulle</td>
    </tr>
    <tr>
      <td>C</td>
      <td>du point du jour</td>
    </tr>
    <tr>
      <td>D</td>
      <td>verdier</td>
    </tr>
    <tr>
      <td>E</td>
      <td>des cours</td>
    </tr>
  </tbody>
</table>

<!-- Ajoutez un espacement entre les deux tableaux -->
<div style="margin-left: 40px;"></div>

<table>
  <thead>
    <tr>
      <th>3-gram</th>
      <th>occurrences</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>gen</td>
      <td>{"A": 1, "B": 1}</td>
    </tr>
    <tr>
      <td>cha</td>
      <td>{"B": 1}</td>
    </tr>
    <tr>
      <td>our</td>
      <td>{"C": 1, "E": 1}</td>
    </tr>
    <tr>
      <td>oin</td>
      <td>{"C": 1}</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
  </tbody>
</table>
</div>

::: {.notes}
- Il y a autant de lignes qu'il ya de trigrams diff√©rents dans les noms de voie du r√©f√©rentiel.  
- Si un mot est inf√©rieur √† la taille n=3, il ne sera pas pris en compte. Par exemple : du g√©n√©ral de gaules, "du" et "de" n‚Äôappara√Ætront pas dans l'index et donc ne seront pas pris en compte dans les matchs trigrams.  
:::

## Score avec tokenizer "n-grams"

Score pour chaque voie :
$$
score_{voie} = \sum_{\text{‚àÄngram} \in \text{N}} {nb\_occurrence}_{ngram}
$$

N = ensemble des n-grams de l'adresse recherch√©e.  

## Limites des n-grams

$$
\downarrow \text{taille n-grams}
\Rightarrow \text{taille index invers√©} \uparrow 
\Rightarrow \text{temps de recherche} \uparrow
$$

- Limitation √† n‚àà{3,4,5} pour notre cas.  
- Tests effectu√©s pour choisir ces valeurs, en fonction de [**la pr√©cision et la rapidit√©**]{.green2} des requ√™tes.  

::: {.notes}
Donc avec tous ces √©l√©ments, on peut commencer √† construire un score de plus en plus efficient pour trouver la voie la plus pertiente.
:::

## Score global 

Le score global va donc combiner la somme des matchs üéØ au niveau :

- mot avec fuzziness.  
- n-grams.  
- mais √©galement texte entier sans d√©coupage !  

<br>

Il est possible de donner plus ou moins d'importance √† ces diff√©rents niveaux de matchs üéØ.  

::: {.notes}
- On va chercher le nom de voie tel quel, sans d√©coupage, au sein de l'adresse recherch√©e.  

- C'est pourquoi on va introduire la notion de boost.  
:::

<!-- ## Configurer le moteur ‚öôÔ∏è

Une fois qu'on a la th√©orie, il faut l'appliquer en pratique.  

Le package elasticsearch permet d'indexer les donn√©es en fournissant :  

- Un dataframe üìã des donn√©es du r√©f√©rentiel Ga√Øa.  
- Des [**settings**]{.blue2} üõ†Ô∏è o√π on d√©finit nos diff√©rents **analyzers**, englobant les filtres et le motizer.  
- Des [**mappings**]{.green2} üè∑Ô∏è o√π pour chaque **variable**, on fournit un analyzer.   -->

## Boost üöÄ

- Chaque occurrence est multipli√©e par un facteur, appel√© [**boost**]{.blue2} üöÄ, qui d√©pend du niveau de match üéØ.  
- Personnalisation des **boosts** üöÄ pour √™tre adapt√© aux donn√©es recherch√©es.  

::: {.notes}
Avec tous ces outils la, on peut faire une recherche !
:::

## Faire des recherches üîç

*Requ√™te üîç pour retrouver la voie :* 

√Ä chaque match üéØ, le score va ‚á° en fonction du boost üöÄ associ√©.

| Variable | Tokenizer | Fuzzi 1 | Boost üöÄ |
|----------|-----------|---------|-----------|
| Nom de voie | Sans d√©coupage | ‚úÖ | 200 |
| Nom de voie | Mot | ‚úÖ | 15 |
| Type de voie | Mot | ‚úÖ | 5 |
| Nom de voie | 3 √† 5-grams | ‚ùå | 1 |

*Ex boost 200 : "3 rue du genral de gaulle" ‚äÉ "du gen[**e**]{.red2}ral de gaulle"*

::: {.notes}
- Requete gaia pour retrouver la voie.  
- Ici, on introduit le type de voie qui n'a pas √©t√© vu pr√©c√©dement, pour ne pas compliquer la compr√©hension de la th√©orie du moteur, mais la logique reste la meme que pour le nom de voie.  
- Attention,  pas de fuzzi sur les ngrams car on juge que les sous chaines sont d√©j√† assez petites, c'est contre productif pour la rapidit√© et la pr√©cision des recherches d'ajouter de la fuzzi.  
- Il faut noter qu'on match √† chaque sous-chaine, par exemple √† chaque 3-grams de verdier dans 88 avenue verdier.  
- Les ngrams c'est notre dernier recours, on va retourner comme voie plus pertinente les match sur nom de voie complet et sur token mais ngrams c'est notre roue de secours.  
:::

## Retour sur le score global

$$
score_{voie} = \sum_{\text{‚àÄn} \in \text{N}} \sum_{\text{‚àÄt} \in \text{n}} boost_{n}*{nb\_occurrence}_{t}
$$

N = ensemble des niveaux *(niveau cha√Æne compl√®te fuzzi, niveau mot fuzzi...)*.  
n = niveau.  
t = token, sous-cha√Æne *(un mot, un 3-grams...)*.  

::: {.notes}
- Formule math√©matique du score pour retrouver la voie la plus pertiente dans Ga√Øa.  

- Maintenant, on est capable de retrouver la voie la plus pertinente, mais qu'est ce qu'il en est de l'adresse ? Regardons l'algorithme d'identification d'adresse de Ga√Øa.  
:::