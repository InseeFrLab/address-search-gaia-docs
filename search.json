[
  {
    "objectID": "src/seminaire-dms/index.html#intro",
    "href": "src/seminaire-dms/index.html#intro",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Intro",
    "text": "Intro"
  },
  {
    "objectID": "src/seminaire-dms/index.html#data",
    "href": "src/seminaire-dms/index.html#data",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Data",
    "text": "Data"
  },
  {
    "objectID": "src/seminaire-dms/index.html#base-de-données-classique",
    "href": "src/seminaire-dms/index.html#base-de-données-classique",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Base de données classique",
    "text": "Base de données classique\nTable 1: Exemple de base de données\n\n\n\nid\nnom de voie\n\n\n\n\nA\ndu général leclerc\n\n\nB\ndu général charles de gaulle\n\n\nC\ndu point du jour\n\n\nD\nverdier\n\n\nE\ndes cours"
  },
  {
    "objectID": "src/seminaire-dms/index.html#recherche-par-token",
    "href": "src/seminaire-dms/index.html#recherche-par-token",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Recherche par token",
    "text": "Recherche par token\nUn token = un mot\nSi on cherche “88 avenue du général charles de gaulle”, pour chaque nom de voie, on doit compter le nombre de : “88”, “avenue”, “du”, “général”…\nC’est extrêment long"
  },
  {
    "objectID": "src/seminaire-dms/index.html#index-inversé-token",
    "href": "src/seminaire-dms/index.html#index-inversé-token",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Index inversé token",
    "text": "Index inversé token\nTable 2: Exemple d’index inversé\n\n\n\ntoken\noccurrences\n\n\n\n\ngénéral\n{“A”: 1, “B”: 1}\n\n\njour\n{“C”: 1}\n\n\nverdier\n{“B”: 1}\n\n\n…\n…\n\n\n\nOn a directement le comptage de chaque token par voie"
  },
  {
    "objectID": "src/seminaire-dms/index.html#score-par-token",
    "href": "src/seminaire-dms/index.html#score-par-token",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Score par token",
    "text": "Score par token\nPour retourner la voie la plus pertinente, on construit un score pour chaque voie : \\[\n\\sum_{\\text{∀t} \\in \\text{T}} occurence_t\n\\]\nt = token\nT = ensemble des tokens de l’adresse recherchée"
  },
  {
    "objectID": "src/seminaire-dms/index.html#recherche-par-n-grams-de-caractères",
    "href": "src/seminaire-dms/index.html#recherche-par-n-grams-de-caractères",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Recherche par n-grams de caractères",
    "text": "Recherche par n-grams de caractères\nContourner les fautes d’orthographes : chaque token est découpé en sous-chaînes de n caractères consécutifs\nExemple : découpage en 3-grams de caractères du texte “avenue verdier”\n\n\n\ntoken\n3-grams\n\n\n\n\navenue\nave, ven, enu, nue\n\n\nverdier\nver, erd, rdi, die, ier"
  },
  {
    "objectID": "src/seminaire-dms/index.html#index-inversé-3-grams",
    "href": "src/seminaire-dms/index.html#index-inversé-3-grams",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Index inversé 3-grams",
    "text": "Index inversé 3-grams\nTable 3: Exemple d’index inversé 3-grams\n\n\n\n3-grams\noccurrences\n\n\n\n\ngén\n{“A”: 1, “B”: 1}\n\n\nchar\n{“B”: 1}\n\n\nour\n{“C”: 1, “E”: 1}\n\n\n…\n…"
  },
  {
    "objectID": "src/seminaire-dms/index.html#score-par-n-grams",
    "href": "src/seminaire-dms/index.html#score-par-n-grams",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Score par n-grams",
    "text": "Score par n-grams\nPour retourner la voie la plus pertinente, on construit un score pour chaque voie : \\[\n\\sum_{\\text{∀ngram} \\in \\text{N}} occurence_{ngram}\n\\]\nN = ensemble des n-grams de l’adresse recherchée"
  },
  {
    "objectID": "src/seminaire-dms/index.html#limites-des-n-grams",
    "href": "src/seminaire-dms/index.html#limites-des-n-grams",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Limites des n-grams",
    "text": "Limites des n-grams\n\\[\n\\downarrow \\text{taille n-grams}\n\\Rightarrow \\text{taille index inversé} \\uparrow\n\\Rightarrow \\text{temps de recherche} \\uparrow\n\\]\nLimitation à minimum n=3 pour notre cas"
  },
  {
    "objectID": "src/seminaire-dms/index.html#fuzziness",
    "href": "src/seminaire-dms/index.html#fuzziness",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Fuzziness",
    "text": "Fuzziness\nContourner les fautes d’orthographes d’une autre façon : fuzziness\nPour matcher deux tokens avec une fuzziness de niveau 1 = corriger l’un des tokens :\n\nAjout d’une lettre\nSuppression d’une lettre\nRemplacement d’une lettre\nEchanger deux lettres de place"
  },
  {
    "objectID": "src/seminaire-dms/index.html#score-global",
    "href": "src/seminaire-dms/index.html#score-global",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Score global",
    "text": "Score global\nLe score global va donc combiner la somme des matchs au niveau :\n\ntoken\nn-grams\nfuzziness\n\nCe score prendra en compte les boosts, le n des n-grams et le niveau de fuzziness choisis au moment du paramétrage du moteur : ceci constitue la requête"
  },
  {
    "objectID": "src/seminaire-dms/index.html#boost",
    "href": "src/seminaire-dms/index.html#boost",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Boost",
    "text": "Boost\nOn peut donner plus ou moins d’importance aux différents matchs grâce aux boosts\nChaque occurence est multipliée par un facteur choisi : boost\nExemple de boosts :\n\n\n\nmatch au niveau\nboost\n\n\n\n\ntoken\n20\n\n\nfuzzi 1\n15\n\n\n3-grams\n1\n\n\n4-ngrams\n1\n\n\n5-grams\n1"
  },
  {
    "objectID": "src/seminaire-dms/index.html#retour-sur-le-score-global",
    "href": "src/seminaire-dms/index.html#retour-sur-le-score-global",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Retour sur le score global",
    "text": "Retour sur le score global\n\\[\n\\sum_{\\text{∀dn} \\in \\text{N}} \\sum_{\\text{∀sc} \\in \\text{dn}} boost_{dn}*occurence_{sc}\n\\]\nN = ensemble des niveaux de découpage de l’adresse recherchée (niveau token, niveau fuzzi…) dn = découpage de l’adresse recherchée selon le niveau (boost associé) sc = sous-chaîne (un token, un 3-grams…)"
  },
  {
    "objectID": "src/seminaire-dms/index.html#résultats",
    "href": "src/seminaire-dms/index.html#résultats",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Résultats",
    "text": "Résultats"
  },
  {
    "objectID": "src/seminaire-dms/index.html#outils",
    "href": "src/seminaire-dms/index.html#outils",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Outils",
    "text": "Outils"
  },
  {
    "objectID": "src/seminaire-dms/index.html#pistes-damélioration",
    "href": "src/seminaire-dms/index.html#pistes-damélioration",
    "title": "Séminaire interne DMS : moteur de recherche d’adresse avec ElasticSearch (Gaïa)",
    "section": "Pistes d’amélioration",
    "text": "Pistes d’amélioration"
  },
  {
    "objectID": "src/documentation/elasticsearch.html",
    "href": "src/documentation/elasticsearch.html",
    "title": "Identification d’adresse",
    "section": "",
    "text": "L’objectif est de founir un service qui prend une adresse en entrée (couple string adresse/string code insee), et renvoie un identifiant Gaïa le plus précis possible et des informations sur la qualité de l’identification. Il y a 3 niveaux d’identifiants Gaïa :\n- IdGaïaAdresse (le plus précis)\n- IdGaïaVoie (lorsque le numéro n’est pas retrouvé, mais que la voie si)\n- idGaïaCommune (lorsque ni l’adresse, ni la voie ne sont identifiées)\nExemple : {“adresseComplete”: “131 rue du faubourg bannier”, “depcom”: “45324”}.\nLe depcom est le Code Officiel Géographique de la commune.\n\n\n\nSchéma algorithme d’identification d’adresse avec ElasticSearch\n\n\n\n\nIl existe deux indices : adresses contenant toutes les adresses fraçaises et voies contenant toutes les voies fraçaises.\nExemple : une adresse est “20 rue hoche” et une voie est “rue hoche”.\nLa première étape est la recherche stricte de l’adresse recherchée dans l’index adresses sur les adresses de la commune uniquement.\nSi aucun IdGaïaAdresse ne ressort à l’issue de l’étape 1, alors :\n- Recherche floue dans l’index voies sur les adresses de la commune uniquement, pour retrouver l’IdGaïaVoie (étape 2).\n- Recherche dans l’index adresses sur les adresses de la voie trouvée à l’étape 1 uniquement, pour retrouver l’idGaïaAdresse (étape 3).\nLa qualité globale de l’appariement est appréciée au travers de deux indicateurs : un code retour qui donne, sur une échelle de 0 à 10, une vision globale sur le retour de l’algorithme et un score relatif pour repérer d’éventuelles concurrences entre réponses de qualité proche.\n\n\nL’information principale est fournie par un code retour, qui vise à indiquer les éléments qui ont été identifiés dans le processus d’appariement.\nL’algorithme recherche d’abord la commune indiquée (pour l’instant cette étape n’est pas faite avec ElasticSearch), puis la voie au sein de la commune et enfin l’adresse dans la voie, c’est-à-dire l’existence du numéro et de l’indice de répétition dans les adresses de la voie.\nLa voie retrouvée est typée selon quatre catégories, en fonction du nombre de trigrammes retrouvés :\n\nvoie sûre : l’adresse contient plus de 65 % des trigrammes de la voie du référentiel\n\nvoie peu douteuse : l’adresse contient entre 35 % et 65 % des trigrammes de la voie du référentiel\n\nvoie douteuse : l’adresse contient entre 10 % et 35 % des trigrammes de la voie du référentiel\n\nvoie non retrouvée : pas d’écho ou l’adresse contient moins de 10 % des trigrammes de la voie du référentiel\n\nEn ce qui concerne les adresses, les contrôles portent sur le numéro et l’indice de répétition :\n\nSi l’adresse demandée ne contient pas d’indice de répétition et que le numéro est trouvé, alors l’adresse est sûre.\n\nSi l’adresse demandée contient un indice de répétition et s’il est retrouvé, l’adresse est sûre.\n\nSi l’adresse demandée contient un indice de répétition mais qu’il n’est pas retrouvé, alors l’adresse est douteuse.\n\nSi le numéro n’est pas retrouvé exactement, aucune adresse n’est retournée.\n\nSi une voie est douteuse, alors la qualité de l’adresse globale est douteuse : on ne distingue donc pas les cas où l’adresse est sûre et douteuse.\n\n\n\n\n\n\n\n\n\nAdresse\nVoie\nCode_retour\nLibellé\n\n\n\n\nsûre\nsûre\n10\nAppariement direct sur l’adresse\n\n\nsûre\nsûre\n9\nAdresse sûre\n\n\ndouteuse\nsûre\n8\nAdresse douteuse dans voie sûre\n\n\nsûre & douteuse\ndouteuse\n7\nAdresse dans voie douteuse\n\n\nsûre & douteuse\ntrès douteuse\n6\nAdresse dans voie très douteuse\n\n\npas d’adresse trouvée\nsûre\n5\nVoie sûre sans adresse\n\n\npas d’adresse trouvée\ndouteuse\n4\nVoie douteuse sans adresse\n\n\npas d’adresse trouvée\ntrès douteuse\n3\nVoie très douteuse sans adresse\n\n\npas d’adresse trouvée\npas de voie trouvée\n2\nCommune seulement\n\n\npas d’adresse trouvée\npas de voie trouvée\n1\nAdresse à l’étranger\n\n\npas d’adresse trouvée\npas de voie trouvée\n0\nProblème dans les données (par exemple, commune non trouvée)\n\n\n\n\n\n\nL’objectif de cette information complémentaire est d’indiquer la position de l’écho retourné par rapport aux autres échos possibles dans l’index voies, lors de la requête à l’étape 2. Il permet d’évaluer si le score Elastic du premier écho (noté R1) est bien supérieur au score du second (noté R2).\nLa formule du ratio est 1-(R2/R1) ; si le score est supérieur à 0,9999, il est ramené à 0,9999.\nSi la valeur est proche de 1, alors le premier écho se détache nettement des autres et donc la recherche est sans ambiguïté. A l’inverse, si la valeur est proche de 0, alors le premier et le second écho ont le même score et la recherche aurait donc pu retourner un autre résultat.\nLe score relatif est compris entre 0 et 1 et donné avec 4 décimales. Le score maximal est de 0,9999, afin de pouvoir être utilisé en combinaison avec le code retour.\n\n\n\n\nLa logique globale de l’algorithme est la suivante :\n\nOn va enchaîner des étapes de contrôles, d’interrogation d’ElasticSearch, de règles de décision.\n\nA chaque étape, il est possible d’attribuer un code retour “sortant” à l’adresse qu’on souhaite identifier. Par exemple, si l’adresse est vide, on attribue un code retour 0 et l’adresse ne va pas plus loin dans l’algorithme.\n\nSi l’adresse n’a pas de code retour attribué, alors on continue dans l’algorithme.\n\nComme précisé plus haut, l’algorithme marche en 4 étapes d’identification: commune —&gt; adresse exacte –si pas de match-&gt; voie —&gt; adresse\n\n\nLes données du client et dans l’index sont traitées de la même façon pour maximiser les matchs :\n- Lowercase\n- Asciifolding\n- Traitement de la ponctuation\n- Utilisation de listes de synonymes\n\n\n\nL’identification à la commune se fait à travers un dictionnaire, pour récupérer l’idGaïaCommune et passer à l’étape suivante.\n\n\n\nAfin d’accélerer notre procédure d’identification, une requête simple et rapide nous permet d’identifier une adresse si son orthographe est parfaite. Cette requête consiste à rechercher au sein des adresses de la commune identifiée à l’étape précédente grâce à un filter sur l’idGaïaCommune, les adresses dont la variable adresseComplete (string représentant l’adresse contenant le numéro, l’indice de répétition, le type et le nom de voie) correspond parfaitement au string envoyé par le client. Ceci est assuré par le caractère stricte de la requête must, accompagné d’un minimum_should_match=100%.\nPour gagner encore plus de temps, la variable adresseComplete ainsi que le string client ne sont pas découpés en token, comme dans les réglages par défaut d’ElasticSearch (le minimum should match est un seuil sur le nombre ou la proportion de bouts matchés entre le résultats de l’index et la demande du client, et un bout peut être le string complet, tout comme un token ou un ngram). Alors, le moteur va retourner l’adresse qui est parfaitement incluse dans le string envoyé.\nEn présence d’un résultat à cette requête, le premier echo est conservé avec un code retour 10 et l’algorithme d’identification se termine à cette étape.\n\n\n\nLa requête pour identifier à la voie est plus complexe car elle inclut la possibilité d’avoir du flou dans l’adresse à rechercher.\nPour faciliter la recherche, un filtre est appliqué pour ne requêter que les voies dans la commune identifiée à l’étape 0.\nC’est une succession de should où au moins l’un d’entre eux doit être validé pour que la voie soit renvoyée :\n- Le nom de voie dans l’index non tokenisé est matché avec une fuzziness de 1 (boost : 200)\n- Le type de voie et/ou le nom de voie du référentiel sont inclus dans l’adresse client avec une fuzziness de 1 (boosts respectifs : 5 et 15)\n- Au moins un ngram du nom de voie de l’index, de taille 3 à 5, correspond (boost par ngram : 1)\nEnsuite, une multitude de vérifications sont appliquées sur le premier echo (s’il existe), qui va déterminer si la voie est sûre, peu douteuse, douteuse ou non retrouvée (citées plus haut).\nS’il n’y a pas de retour ElasticSearch ou si la voie est jugée comme non retrouvée d’après les règles, un code retour 2 sera affiché.\n\n\n\nPour retrouver l’adresse à partir de la voie, nous allons chercher dans les adresses de la voie identifiée à l’étape 2 (avec un filter sur idGaïaVoie) et demander à matcher sur les champs numéro et/ou indice de répétition dans notre base.\nDes regex ont été développées pour extraire le numéro de l’adresse dans le string client et qui détecte la présence d’indice de répétition dans celle-ci. Ensuite, un must est appliqué sur le champ numéro avec l’extraction du numéro. Si l’extraction ne retourne rien, le numéro recherché par le must sera alors “0”. L’indice de répétition sera recherché avec un should.\nSi le moteur retourne plusieurs adresses, l’adresse retournée sera :\n- celle qui a un indice de répétition si un indice a été détecté dans l’adresse recherchée\n- celle qui n’a pas d’indice de répétition si aucun indice n’a été détecté dans l’adresse recherchée\nDans le cas où un idGaïaAdresse est trouvé, il sera accompagné d’un code retour 7, 8 ou 9.\nFinalement, dans le cas où aucune adresse ne ressort, alors un code retour 3, 4 ou 5 sera attribué en fonction de la fiabilité de la voie identifiée.",
    "crumbs": [
      "Accueil",
      "Navigation",
      "Identification d'adresse avec ElasticSearch"
    ]
  },
  {
    "objectID": "src/documentation/elasticsearch.html#fonctionnement-de-lidentification",
    "href": "src/documentation/elasticsearch.html#fonctionnement-de-lidentification",
    "title": "Identification d’adresse",
    "section": "",
    "text": "Il existe deux indices : adresses contenant toutes les adresses fraçaises et voies contenant toutes les voies fraçaises.\nExemple : une adresse est “20 rue hoche” et une voie est “rue hoche”.\nLa première étape est la recherche stricte de l’adresse recherchée dans l’index adresses sur les adresses de la commune uniquement.\nSi aucun IdGaïaAdresse ne ressort à l’issue de l’étape 1, alors :\n- Recherche floue dans l’index voies sur les adresses de la commune uniquement, pour retrouver l’IdGaïaVoie (étape 2).\n- Recherche dans l’index adresses sur les adresses de la voie trouvée à l’étape 1 uniquement, pour retrouver l’idGaïaAdresse (étape 3).\nLa qualité globale de l’appariement est appréciée au travers de deux indicateurs : un code retour qui donne, sur une échelle de 0 à 10, une vision globale sur le retour de l’algorithme et un score relatif pour repérer d’éventuelles concurrences entre réponses de qualité proche.\n\n\nL’information principale est fournie par un code retour, qui vise à indiquer les éléments qui ont été identifiés dans le processus d’appariement.\nL’algorithme recherche d’abord la commune indiquée (pour l’instant cette étape n’est pas faite avec ElasticSearch), puis la voie au sein de la commune et enfin l’adresse dans la voie, c’est-à-dire l’existence du numéro et de l’indice de répétition dans les adresses de la voie.\nLa voie retrouvée est typée selon quatre catégories, en fonction du nombre de trigrammes retrouvés :\n\nvoie sûre : l’adresse contient plus de 65 % des trigrammes de la voie du référentiel\n\nvoie peu douteuse : l’adresse contient entre 35 % et 65 % des trigrammes de la voie du référentiel\n\nvoie douteuse : l’adresse contient entre 10 % et 35 % des trigrammes de la voie du référentiel\n\nvoie non retrouvée : pas d’écho ou l’adresse contient moins de 10 % des trigrammes de la voie du référentiel\n\nEn ce qui concerne les adresses, les contrôles portent sur le numéro et l’indice de répétition :\n\nSi l’adresse demandée ne contient pas d’indice de répétition et que le numéro est trouvé, alors l’adresse est sûre.\n\nSi l’adresse demandée contient un indice de répétition et s’il est retrouvé, l’adresse est sûre.\n\nSi l’adresse demandée contient un indice de répétition mais qu’il n’est pas retrouvé, alors l’adresse est douteuse.\n\nSi le numéro n’est pas retrouvé exactement, aucune adresse n’est retournée.\n\nSi une voie est douteuse, alors la qualité de l’adresse globale est douteuse : on ne distingue donc pas les cas où l’adresse est sûre et douteuse.\n\n\n\n\n\n\n\n\n\nAdresse\nVoie\nCode_retour\nLibellé\n\n\n\n\nsûre\nsûre\n10\nAppariement direct sur l’adresse\n\n\nsûre\nsûre\n9\nAdresse sûre\n\n\ndouteuse\nsûre\n8\nAdresse douteuse dans voie sûre\n\n\nsûre & douteuse\ndouteuse\n7\nAdresse dans voie douteuse\n\n\nsûre & douteuse\ntrès douteuse\n6\nAdresse dans voie très douteuse\n\n\npas d’adresse trouvée\nsûre\n5\nVoie sûre sans adresse\n\n\npas d’adresse trouvée\ndouteuse\n4\nVoie douteuse sans adresse\n\n\npas d’adresse trouvée\ntrès douteuse\n3\nVoie très douteuse sans adresse\n\n\npas d’adresse trouvée\npas de voie trouvée\n2\nCommune seulement\n\n\npas d’adresse trouvée\npas de voie trouvée\n1\nAdresse à l’étranger\n\n\npas d’adresse trouvée\npas de voie trouvée\n0\nProblème dans les données (par exemple, commune non trouvée)\n\n\n\n\n\n\nL’objectif de cette information complémentaire est d’indiquer la position de l’écho retourné par rapport aux autres échos possibles dans l’index voies, lors de la requête à l’étape 2. Il permet d’évaluer si le score Elastic du premier écho (noté R1) est bien supérieur au score du second (noté R2).\nLa formule du ratio est 1-(R2/R1) ; si le score est supérieur à 0,9999, il est ramené à 0,9999.\nSi la valeur est proche de 1, alors le premier écho se détache nettement des autres et donc la recherche est sans ambiguïté. A l’inverse, si la valeur est proche de 0, alors le premier et le second écho ont le même score et la recherche aurait donc pu retourner un autre résultat.\nLe score relatif est compris entre 0 et 1 et donné avec 4 décimales. Le score maximal est de 0,9999, afin de pouvoir être utilisé en combinaison avec le code retour.",
    "crumbs": [
      "Accueil",
      "Navigation",
      "Identification d'adresse avec ElasticSearch"
    ]
  },
  {
    "objectID": "src/documentation/elasticsearch.html#algorithme-didentification",
    "href": "src/documentation/elasticsearch.html#algorithme-didentification",
    "title": "Identification d’adresse",
    "section": "",
    "text": "La logique globale de l’algorithme est la suivante :\n\nOn va enchaîner des étapes de contrôles, d’interrogation d’ElasticSearch, de règles de décision.\n\nA chaque étape, il est possible d’attribuer un code retour “sortant” à l’adresse qu’on souhaite identifier. Par exemple, si l’adresse est vide, on attribue un code retour 0 et l’adresse ne va pas plus loin dans l’algorithme.\n\nSi l’adresse n’a pas de code retour attribué, alors on continue dans l’algorithme.\n\nComme précisé plus haut, l’algorithme marche en 4 étapes d’identification: commune —&gt; adresse exacte –si pas de match-&gt; voie —&gt; adresse\n\n\nLes données du client et dans l’index sont traitées de la même façon pour maximiser les matchs :\n- Lowercase\n- Asciifolding\n- Traitement de la ponctuation\n- Utilisation de listes de synonymes\n\n\n\nL’identification à la commune se fait à travers un dictionnaire, pour récupérer l’idGaïaCommune et passer à l’étape suivante.\n\n\n\nAfin d’accélerer notre procédure d’identification, une requête simple et rapide nous permet d’identifier une adresse si son orthographe est parfaite. Cette requête consiste à rechercher au sein des adresses de la commune identifiée à l’étape précédente grâce à un filter sur l’idGaïaCommune, les adresses dont la variable adresseComplete (string représentant l’adresse contenant le numéro, l’indice de répétition, le type et le nom de voie) correspond parfaitement au string envoyé par le client. Ceci est assuré par le caractère stricte de la requête must, accompagné d’un minimum_should_match=100%.\nPour gagner encore plus de temps, la variable adresseComplete ainsi que le string client ne sont pas découpés en token, comme dans les réglages par défaut d’ElasticSearch (le minimum should match est un seuil sur le nombre ou la proportion de bouts matchés entre le résultats de l’index et la demande du client, et un bout peut être le string complet, tout comme un token ou un ngram). Alors, le moteur va retourner l’adresse qui est parfaitement incluse dans le string envoyé.\nEn présence d’un résultat à cette requête, le premier echo est conservé avec un code retour 10 et l’algorithme d’identification se termine à cette étape.\n\n\n\nLa requête pour identifier à la voie est plus complexe car elle inclut la possibilité d’avoir du flou dans l’adresse à rechercher.\nPour faciliter la recherche, un filtre est appliqué pour ne requêter que les voies dans la commune identifiée à l’étape 0.\nC’est une succession de should où au moins l’un d’entre eux doit être validé pour que la voie soit renvoyée :\n- Le nom de voie dans l’index non tokenisé est matché avec une fuzziness de 1 (boost : 200)\n- Le type de voie et/ou le nom de voie du référentiel sont inclus dans l’adresse client avec une fuzziness de 1 (boosts respectifs : 5 et 15)\n- Au moins un ngram du nom de voie de l’index, de taille 3 à 5, correspond (boost par ngram : 1)\nEnsuite, une multitude de vérifications sont appliquées sur le premier echo (s’il existe), qui va déterminer si la voie est sûre, peu douteuse, douteuse ou non retrouvée (citées plus haut).\nS’il n’y a pas de retour ElasticSearch ou si la voie est jugée comme non retrouvée d’après les règles, un code retour 2 sera affiché.\n\n\n\nPour retrouver l’adresse à partir de la voie, nous allons chercher dans les adresses de la voie identifiée à l’étape 2 (avec un filter sur idGaïaVoie) et demander à matcher sur les champs numéro et/ou indice de répétition dans notre base.\nDes regex ont été développées pour extraire le numéro de l’adresse dans le string client et qui détecte la présence d’indice de répétition dans celle-ci. Ensuite, un must est appliqué sur le champ numéro avec l’extraction du numéro. Si l’extraction ne retourne rien, le numéro recherché par le must sera alors “0”. L’indice de répétition sera recherché avec un should.\nSi le moteur retourne plusieurs adresses, l’adresse retournée sera :\n- celle qui a un indice de répétition si un indice a été détecté dans l’adresse recherchée\n- celle qui n’a pas d’indice de répétition si aucun indice n’a été détecté dans l’adresse recherchée\nDans le cas où un idGaïaAdresse est trouvé, il sera accompagné d’un code retour 7, 8 ou 9.\nFinalement, dans le cas où aucune adresse ne ressort, alors un code retour 3, 4 ou 5 sera attribué en fonction de la fiabilité de la voie identifiée.",
    "crumbs": [
      "Accueil",
      "Navigation",
      "Identification d'adresse avec ElasticSearch"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Moteur de recherche d’adresse Gaïa",
    "section": "",
    "text": "Moteur de recherche d’adresse Gaïa\n\n\n\n\n  \n     \n      \n        \n          \n            \n          \n         \n        \n          \n            Documentation\n            \n\n            \n              Description : Ici est rassemblée toute la documentation technique sur le moteur de recherche d'adresse textuel Gaïa\n\n            \n\n            \n            \n              \n                Raya Berova\n                Nov 13, 2024\n              \n            \n            \n            \n              \n                \n                  \n                    \n                      \n                        doc\n                      \n                    \n                  \n                \n              \n            \n          \n        \n\n        \n\n      \n     \n  \n\n  \n     \n      \n        \n          \n            \n          \n         \n        \n          \n            Séminaire interne DMS\n            \n\n            \n              Description : Ce séminaire a pour but de présenter le moteur de recherche d'adresse Gaïa et de diffuser les connaissances sur ElasticSearch au sein de l'Insee.\n\n            \n\n            \n            \n              \n                Raya Berova\n                Nov 13, 2024\n              \n            \n            \n            \n              \n                \n                  \n                    \n                      \n                        pdf\n                      \n                    \n                  \n                \n              \n            \n          \n        \n\n        \n\n      \n     \n  \n\n  \n     \n      \n        \n          \n            \n          \n         \n        \n          \n            Abstract NTTS 2025 (Eurostat)\n            \n\n            \n              Description : Abstract en anglais soumis à NTTS 2025.\n\n            \n\n            \n            \n              \n                Raya Berova\n                Nov 13, 2024\n              \n            \n            \n            \n              \n                \n                  \n                    \n                      \n                        pdf\n                      \n                    \n                  \n                \n              \n            \n          \n        \n\n        \n\n      \n     \n  \n\n\n\n\nNo matching items"
  },
  {
    "objectID": "src/documentation/index.html",
    "href": "src/documentation/index.html",
    "title": "Accueil de la documentation",
    "section": "",
    "text": "Informations de connexion via Filezilla en protocole FTP (connexion FTP simple)\n\n\n\n\n\n\n\n\nPlateforme\nURL\nVM\n\n\n\n\nDV\nhttps://api-interrogation-geo.developpement.insee.fr/swagger-ui/index.html\ndvgaialm001\n\n\nDV2\nhttps://api-interrogation-geo.developpement2.insee.fr/swagger-ui/index.html\ndvgaialm002\n\n\nPREPROD\nhttps://api-interrogation-geo.preprod.insee.fr/swagger-ui/index.html\npdgaialm001/2/3\n\n\nPROD\nhttps://api-interrogation-geo.insee.fr/swagger-ui/index.html\npdgaialm001/2/3\n\n\n\nPour requêter le service d’identification, il faut que l’utilisateur soit authentifié en ayant récupéré un jeton Keycloak au préalable et qu’il bénéficie du rôle IDENTIFICATION_GAIA. Si ce n’est pas le cas, contactez l’équipe Gaïa sur Tchap ou mail.\n\n\n\nPour lancer une identification avec le moteur ElasticSearch développé en python, il faut aller sur le dépôt git et lire le README. Il est possible d’accéder au dépôt en cliquant ici Moteur de recherche Gaïa. Puis aller sur LS3 pour cloner le projet.\n⚠️ Attention : il faut avoir les droits pour accéder au dépôt et être dans le projet LS3. Si ce n’est pas le cas, contactez l’équipe Gaïa sur Tchap ou mail.",
    "crumbs": [
      "Accueil",
      "Navigation",
      "Accueil"
    ]
  },
  {
    "objectID": "src/documentation/index.html#recherche-simple-les-swaggers",
    "href": "src/documentation/index.html#recherche-simple-les-swaggers",
    "title": "Accueil de la documentation",
    "section": "",
    "text": "Informations de connexion via Filezilla en protocole FTP (connexion FTP simple)\n\n\n\n\n\n\n\n\nPlateforme\nURL\nVM\n\n\n\n\nDV\nhttps://api-interrogation-geo.developpement.insee.fr/swagger-ui/index.html\ndvgaialm001\n\n\nDV2\nhttps://api-interrogation-geo.developpement2.insee.fr/swagger-ui/index.html\ndvgaialm002\n\n\nPREPROD\nhttps://api-interrogation-geo.preprod.insee.fr/swagger-ui/index.html\npdgaialm001/2/3\n\n\nPROD\nhttps://api-interrogation-geo.insee.fr/swagger-ui/index.html\npdgaialm001/2/3\n\n\n\nPour requêter le service d’identification, il faut que l’utilisateur soit authentifié en ayant récupéré un jeton Keycloak au préalable et qu’il bénéficie du rôle IDENTIFICATION_GAIA. Si ce n’est pas le cas, contactez l’équipe Gaïa sur Tchap ou mail.",
    "crumbs": [
      "Accueil",
      "Navigation",
      "Accueil"
    ]
  },
  {
    "objectID": "src/documentation/index.html#recherche-avancée-code-python",
    "href": "src/documentation/index.html#recherche-avancée-code-python",
    "title": "Accueil de la documentation",
    "section": "",
    "text": "Pour lancer une identification avec le moteur ElasticSearch développé en python, il faut aller sur le dépôt git et lire le README. Il est possible d’accéder au dépôt en cliquant ici Moteur de recherche Gaïa. Puis aller sur LS3 pour cloner le projet.\n⚠️ Attention : il faut avoir les droits pour accéder au dépôt et être dans le projet LS3. Si ce n’est pas le cas, contactez l’équipe Gaïa sur Tchap ou mail.",
    "crumbs": [
      "Accueil",
      "Navigation",
      "Accueil"
    ]
  }
]